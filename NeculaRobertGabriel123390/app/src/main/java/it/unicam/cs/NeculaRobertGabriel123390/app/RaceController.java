package it.unicam.cs.NeculaRobertGabriel123390.app;

import it.unicam.cs.NeculaRobertGabriel123390.api.model.*;
import it.unicam.cs.NeculaRobertGabriel123390.api.model.log.RaceLogger;
import it.unicam.cs.NeculaRobertGabriel123390.api.model.manager.RaceManager;
import it.unicam.cs.NeculaRobertGabriel123390.api.model.race.Race;
import it.unicam.cs.NeculaRobertGabriel123390.api.model.race.RaceValidator;
import it.unicam.cs.NeculaRobertGabriel123390.api.model.scenebuilder.CircuitSceneBuilder;
import it.unicam.cs.NeculaRobertGabriel123390.api.model.scenebuilder.MovesGridSceneBuilder;
import it.unicam.cs.NeculaRobertGabriel123390.api.model.scenebuilder.PlayersSceneBuilder;
import javafx.event.Event;
import javafx.fxml.FXML;

import javafx.fxml.FXMLLoader;
import javafx.scene.control.Button;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;

import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;
import javafx.stage.Stage;

import java.util.Random;


/**
 * Controller for the race scene, handling the interaction between the user, game state, and UI.
 */
public class RaceController {


    @FXML
    private Pane circuitGrid;


    @FXML
    private GridPane playersGrid;


    @FXML
    private Text currentPlayerPlayingText;


    @FXML
    private GridPane inputMovesGrid;


    @FXML
    private TextFlow raceLogArea;


    @FXML
    private ScrollPane raceLogAreaScrollPane;


    private final Race race;


    private RaceManager raceManager;


    private Renderer renderer;


    private CircuitSceneBuilder circuitSceneBuilder;


    private PlayersSceneBuilder playersSceneBuilder;


    private MovesGridSceneBuilder movesGridSceneBuilder;

    /**
     * Constructor for the RaceController.
     *
     * @param race The race object to be managed by this controller.
     */
    public RaceController(Race race) {
        RaceValidator.validate(race);
        this.race = race;
    }


    /**
     * Builds the entire race scene based on the provided race data.
     * Initializes the race manager, renders the circuit, sets up player grids, and displays the current player.
     */
    public void build() {

        if(!RaceLogger.isInitialized)
            RaceLogger.initialize(this.raceLogArea, this.raceLogAreaScrollPane);
        this.raceManager = new RaceManager(this.race);

        initializeSceneBuilders();
        renderSceneBuilders();
        displayCurrentPlayer();
    }


    /**
     * Renders the scene builders for the circuit, players, and moves grid.
     * This includes initializing the renderer and displaying the initial player positions.
     */
    private void renderSceneBuilders() {
        this.renderer = new Renderer();

        this.renderer.render(this.circuitSceneBuilder, this.playersSceneBuilder, this.movesGridSceneBuilder);
        this.playersSceneBuilder.displayInitialPlayerPosition(this.circuitSceneBuilder.getContainer());
    }


    /**
     * Initializes the scene builders with the corresponding UI components and game data.
     */
    private void initializeSceneBuilders() {
        this.circuitSceneBuilder = new CircuitSceneBuilder(this.circuitGrid, this.race.circuit());
        this.playersSceneBuilder = new PlayersSceneBuilder(this.playersGrid, this.raceManager.getInitialPlayersPositions());
        this.movesGridSceneBuilder = new MovesGridSceneBuilder(this.inputMovesGrid, new PlayerMoves());
    }


    /**
     * Handles player move events triggered by button presses.
     * Updates the game state and view based on the move result.
     * @throws NullPointerException If the event is null
     * @param event The event generated by the button press.
     */
    @FXML
    public void handlePlayerMove(Event event){
        if(event == null)
            throw new NullPointerException("Event is null");


        Button button = (Button) event.getSource();
        Position buttonPosition = (Position) button.getUserData();

        MoveResult moveResult = this.raceManager.onPlayerMove(buttonPosition);
        processMoveResult(moveResult);
    }


    /**
     * Processes the result of a player's move and updates the view or handles special cases (e.g., win, no winner ecc).
     *
     * @param moveResult The result of the move.
     * @throws IllegalStateException if the moveType is not valid.
     */
    private void processMoveResult(MoveResult moveResult) {
        MoveResultValidator.validate(moveResult);

        switch (moveResult.moveType()) {
            case MoveResultType.SUCCESS, MoveResultType.COLLISION_ALLOWED ->{
                updateView(moveResult);
                updateTurnData();
            }

            case MoveResultType.CRASH_CONTINUE_WITH_PENALTY, MoveResultType.COLLISION_NOT_ALLOWED -> updateTurnData();

            case MoveResultType.CRASH_LEAVE_RACE -> {
                if(this.raceManager.wasLastPlayer())
                    handleNoWinner();
                else {
                    updateView(moveResult);
                    updateTurnData();
                }
            }

            case MoveResultType.WIN -> handleWin(moveResult);

            default -> throw new IllegalStateException("Unexpected value: " + moveResult.moveType());
        }
    }


    /**
     * Updates the view based on the provided move result and displays the current player.
     *
     * @param moveResult The updated move result.
     */
    private void updateView(MoveResult moveResult) {
        MoveResultValidator.validate(moveResult);
        this.renderer.update(this.circuitSceneBuilder, moveResult);
        this.renderer.update(this.playersSceneBuilder, moveResult);
    }


    /**
     * Updates the move grid for the next player and handles bot moves if applicable.
     */
    private void updateTurnData() {
        PlayerMoves nextPlayerMoves = this.raceManager.getCurrentPlayerMoves();
        this.renderer.update(this.movesGridSceneBuilder, nextPlayerMoves);
        handleMoveIfBot(nextPlayerMoves);
        displayCurrentPlayer();
    }


    /**
     * Handles the case where the current player is a bot by making a random move.
     * @param nextPlayerMoves The possible moves for the current player.
     * @throws NullPointerException If {@code nextPlayerMoves} is null;
     */
    private void handleMoveIfBot(PlayerMoves nextPlayerMoves) {
        if(nextPlayerMoves == null)
            throw new NullPointerException("nextPlayerMoves is null");

        if(this.raceManager.getCurrentPlayer().isBot() ) {
            Position randomMove = nextPlayerMoves.getMoves()[getRandomIndex()][getRandomIndex()];
            MoveResult moveResult = this.raceManager.onPlayerMove(randomMove);
            processMoveResult(moveResult);
        }
    }


    /**
     * Displays the win scene when a player crosses the finish line.
     *
     * @param moveResult The result of the move leading to the win.
     */
    private void handleWin(MoveResult moveResult) {
        MoveResultValidator.validate(moveResult);

        updateView(moveResult);
        loadWinScene(moveResult);
    }


    /**
     * Handles the case where there is no winner left in the race.
     * This method disables the grid to prevent further moves and loads the "No Winner" scene.
     * It is typically called when the last player crashes and leaves the race.
     */
    private void handleNoWinner() {
        this.movesGridSceneBuilder.disableGrid();
        loadNoWinnerScene();
    }


    /**
     * Displays the win scene with the player who has won.
     *
     * @param moveResult The result of the winning move.
     */
    private void loadWinScene(MoveResult moveResult) {
        MoveResultValidator.validate(moveResult);

        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("/fxml/WinScene.fxml"));
        WinController winController = new WinController();
        fxmlLoader.setController(winController);
        Stage stage = (Stage) this.inputMovesGrid.getScene().getWindow();

        SceneLoader.loadNewScene(fxmlLoader, stage);
        winController.displayWinner(moveResult.player());
    }


    /**
     * Loads and displays the "No Winner" scene.
     * This scene is shown when the race concludes with no players remaining, indicating that no player won the race.
     * It replaces the current race scene with a predefined "No Winner" scene defined in the FXML file.
     */
    private void loadNoWinnerScene() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/NoWinnerScene.fxml"));
        Stage stage = (Stage) this.inputMovesGrid.getScene().getWindow();
        SceneLoader.loadNewScene(loader, stage);
    }



    /**
     * Displays the name of the current player.
     */
    private void displayCurrentPlayer(){
        String currentPlayerName = this.raceManager.getCurrentPlayer().getName();
        this.currentPlayerPlayingText.setText(currentPlayerName);
    }


    /**
     * Method used to get a random index between 0 and 2 to choose a random move for a bot player
     * @return int A random index between 0 and 2
     */
    private int getRandomIndex() {return new Random().nextInt(3);}


}
